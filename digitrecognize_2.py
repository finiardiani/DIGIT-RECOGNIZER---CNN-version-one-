# -*- coding: utf-8 -*-
"""DigitRecognize_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EX26ms3lSO5O0fVuScvNS1Bt4SzvdpML

#DIGIT RECOGNIZER - CNN
###pengenalan angka menggunakan model Convolutional Neural Network (CNN) sederhana 1 layer
"""

# upload file
from google.colab import files
files.upload()

"""# DATA UNDERSTANDING"""

# Commented out IPython magic to ensure Python compatibility.
# import modul
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

sns.set_style("darkgrid")
import warnings
warnings.filterwarnings('ignore')

plt.style.use('seaborn')
# %matplotlib inline
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset, TensorDataset
from keras.utils import np_utils
from keras.datasets import mnist

from sklearn.metrics import confusion_matrix
import sklearn
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.utils import to_categorical

from keras.models import Sequential
from keras.layers import Dense

# read data
train = pd.read_csv('train.csv')
test = pd.read_csv('test.csv')

# tampilkan train
train.head()

# deskripsi train
train.describe()

# info train
train.info()

# ukuran train
train.shape

# train label value_count
train['label'].value_counts()

# tampilkan test
test.head()

# deskripsi test
test.describe()

# info test
test.info()

# ukuran test
test.shape

"""# DATA VISUALIZATION

### Tentukan nilai x dan y dari train dan test
"""

# tentukan variabel dependen y_train yaitu train label
y_train = train['label']
# tentukan variabel x_train yaitu seluruh kolom dalam train kecuali kolom label
X_train = train.drop(labels=['label'], axis=1)
# tentukan x_test yaitu semua nilai dalam test
X_test = test

# countplot y_train
sns.countplot(y_train)

# plot distribusi y_train
sns.distplot(y_train)

# plot gambar tabel X_train dari range index 0-5
for i in range(0,5):
    # index pada tiap baris X_train akan bertambah 1, dan reshape tiap baris X_train menjadi 28x28 pixel
    digit=(X_train.iloc[i:i+1,:].to_numpy()).reshape(28,28)
    # atur ukuran gambar 
    plt.figure(figsize=(1.5,1.5))
    #tampilkan gambar
    plt.imshow(digit, 'gray')

# cocokan 5 gambar yang terlihat dari plot, dengan 5 nilai dari y_train
y_train.head(5)

# plot gambar tabel X_test dari range index 0-5
for i in range(0,5):
    # index pada tiap baris X_test akan bertambah 1, dan reshape tiap baris X_test menjadi 28x28 pixel
    digit=(X_test.iloc[i:i+1,:].to_numpy()).reshape(28,28)
    # atur ukuran gambar 
    plt.figure(figsize=(1.5,1.5))
    #tampilkan gambar
    plt.imshow(digit, 'gray')

"""# DATA PREPARATION

### HANDLING MISSING VALUE
"""

# cek misiing value pada train
train.isnull().sum()[train.isnull().sum()>0]

# cek misiing value pada test
test.isnull().sum()[test.isnull().sum()>0]

# cek misiing value pada X_train
X_train.isnull().sum()[X_train.isnull().sum()>0]

# cek misiing value pada X_test
X_test.isnull().sum()[X_test.isnull().sum()>0]

# cek misiing value pada y_train
y_train.isnull().sum()[y_train.isnull().sum()>0]

"""### DATA NORMALIZATION
karena X_train dan X_test tidak berdistribusi normal, maka X_train dan X_test harus di trainsformasi dengan membagikan nilai X_train dan X_test dengan 255. Dimana 255 merupakan nilai pixel dari tiap gambar yaitu atara 0-255 menjadi antara 0-1.
"""

# normalisasi X_train
X_train = X_train / 255
# normalisasi X_test
X_test = X_test / 255

# tampilkan X_train yg telah dinormalisasi
X_train

# tampilkan X_test yang telah dinormalisasi
X_test

"""### DATA FORMATING"""

# ubah type data X_train menjadi float32
X_train = X_train.values.astype('float32')
# ubah type data y_train menjadi integer 
y_train = y_train.values.astype('int32')
# ubah type data X_test menjadi float32 
X_test = test.values.astype('float32')

# cek ukuran data
print('Ukuran X_train : ', X_train.shape)
print('Ukuran y_train : ', y_train.shape)
print('Ukuran X_test  : ', X_test.shape)

"""Convert nilai y_train dengan menggunakan metode one-hot menjadi matriks biner yang memiliki ukuran 1x9 karena nilai y_train berada diantara 0-9, yang berbentuk
*  y_train bernilai 1 hasil convert [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
*  y_train bernilai 0 hasil convert [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
*  y_train bernilai 1 hasil convert [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
*  y_train bernilai 4 hasil convert [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
*  y_train bernilai 0 hasil convert [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"""

# tampilkan train['label]
train['label'].head(5)

# convert y_train menjadi matriks binery 
Y_train = np_utils.to_categorical(y_train)
Y_train

# cek ukuran dalam tiap matriksnya
Y_train.shape[1]

# recek ukuran y_train dan Y_train
print('Ukuran y_train :', y_train.shape)
print('Ukuran Y_train :', Y_train.shape)

"""### SPLIT DATA 
split/bagi data X_train dan Y_train menjadi 80% data training dan 20% data validation
"""

# split data train menjadi 80 data traini dan 20% data validation
X_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = 0.10, random_state=7)

# recek kembali ukuran data yang telah displit
print('Ukuran X_train :', X_train.shape)
print('Ukuran X_val   :', X_val.shape)
print('Ukuran Y_train :', Y_train.shape)
print('Ukuran Y_val   :', Y_val.shape)

# tampilkan Y_val
Y_val

# kembalikan nilai Y_val yang telah dikonvert menggunakan metode one-hot kedalam bentuk awal
y_val = np.argmax(Y_val, 1)
y_val

"""# MODELING
https://machinelearning.mipa.ugm.ac.id/2018/09/30/klasifikasi-gambar-sederhana-menggunakan-convolutional-neural-network/

### Model Convolutional neural networks (CNN) Sederhana
buat model CNN sederhana dengan hanya menggunakan 1 layer
"""

# banyak kolom X_train
num_pixels = X_train.shape[1]
num_pixels

# definisikan sebuah fungsi untuk model sederhana
def baseline_model():
    # buat model CNN dengan metode Sequential
    model = Sequential()
    # atur dense untuk mengatur connection neural network dari model
    model.add(Dense(784, input_dim=784, kernel_initializer='normal', activation='relu'))
    model.add(Dense(10, kernel_initializer='normal', activation='softmax'))
    # compile model agar menampilkan loss function dan perfoma model
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
    return model

# fit model dengan menggunakan 15 iterasi dan dan batch size 200
model = baseline_model()
history = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=15, batch_size=200, verbose=1)

# cetak seluruh nilai pada model yang di fit 
history_dict = history.history
history_dict

# Cetak kunci dari setiap nilai dari model yang difitkan 
history_dict.keys()

# plot fungsi validasi dari y_val dan predicted
plt.plot(history.history['loss'], label = 'Loss Training')
plt.plot(history.history['val_loss'], label = 'Loss Validation')
plt.title('Loss Plot')
plt.ylabel('Value')
plt.xlabel('Epoch')
plt.legend(loc="upper right")
plt.show()

# plot tingkat akurasi dari y_val dan predicted
plt.plot(history.history['accuracy'], label = 'Akurasi Train')
plt.plot(history.history['val_accuracy'], label = 'Akurasi Validation')
plt.title('Plot Akurasi')
plt.ylabel('Value')
plt.xlabel('Epoch')
plt.legend(loc="lower right")
plt.show()

# tentang model
model.summary()

"""## Evaluasi Model
Evaluasi model yang dihasilkan dengan menggunkan medel CNN sederhana
"""

# Evaluasi model CNN sederhana yang dihasilkan
scores = model.evaluate(X_val, Y_val, verbose=0)
print ('nilai skor dan akurasi model :',scores)
print ('Score model                  :',format(scores[0]))
print ('Accuracy model               :',format(scores[1]))

"""## Koreksi hasil prediksi 
Koreksi hasil prediksi yang dihasilkan dengan menggunakan model CNN sederhana dengan menggunakan data validation yaitu X_val apakah hasil yang diberikan bebar atau salah.
"""

# definisikan variabel predicted_classes yang berisi nilai yang akan diprediksi
predicted = model.predict_classes(X_val)
predicted

# indeks hasil prediksi yang bernilai sama dengan nilai y_val, atau dapat dikatakan prediksinya bebar
correct = np.nonzero(np.equal(predicted, y_val))[0]
correct

# banyanya prediksi yang benar
len(correct)

# # indeks hasil prediksi yang nilainya tidak sama dengan nilai y_val, atau dapat dikatakan prediksinya salah
incorrect = np.nonzero(np.not_equal(predicted, y_val))[0]
incorrect

# banyaknya prediksi yang salah
len(incorrect)

# plot gambar hasil prediksi yang bernilai salah

# atur ukuran gambar yaotu 16, 10
plt.figure(figsize=[20,8])
for i, incorrect in enumerate(incorrect[:6]):
    # tampilkan gambar 
    plt.subplot(1,6,i+1)
    # tampilkan gambar dengan ukuran 28x28 pixel dengan skala warna abu-abu
    plt.imshow(X_val[incorrect].reshape(28,28), cmap='gray', interpolation='none')
    # atur judul 
    plt.title("Prediksi {}, Aktual {}".format(predicted[incorrect], y_val[incorrect]))

# plot gambar hasil prediksi yang bernilai bebar

# atur ukuran gambar yaotu 16, 10
plt.figure(figsize=[20,8])
for i, correct in enumerate(correct[:6]):
    # tampilkan gambar 
    plt.subplot(1,6,i+1)
    # tampilkan gambar dengan ukuran 28x28 pixel dengan skala warna abu-abu
    plt.imshow(X_val[correct].reshape(28,28), cmap='gray', interpolation='none')
    # atur judul 
    plt.title("Prediksi {}, Aktual {}".format(predicted[correct], y_val[correct]))

"""#Confution Matrix
bandingkan nilai sebenrnya dan hasil prediksi dengan menggunakan confusion matriks.
"""

# nilai unik dalam y_train
class_names = np.unique(y_train)
class_names

# hitung matriks confusion dari y_val dan redicted
cnf_matrix = confusion_matrix(y_val, predicted)
np.set_printoptions(precision=2)

# cetan matriks confusion dari y_val dan Predicted dari 10 kelas yaitu 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
print (cnf_matrix)

# hitung matriks persentase confusion y_val dan predictednya 
# dengan cara membagikan tiap nilai matrik dengan jumlah keseluruhan nilai pada kolomnya
cnf_matrix_percent = cnf_matrix.astype('float') / cnf_matrix.sum(axis=1)[:, np.newaxis]

# cetak matriks persentase konfusionya 
print(cnf_matrix_percent)

# prediksi nilai prediksi menggunakan X_test
predicted = model.predict_classes(X_test)
predicted

# cek ukuran hasil prediksinya
predicted.shape

# buat dataframe baru yang berisi data yg akan disubmit ke kaggle
submissions = pd.DataFrame({'ImageId': list(range(1, len(predicted) + 1)), 
                            "Label": predicted})
submissions

# save data submission
submissions.to_csv("submission.csv", index=False, header=True)